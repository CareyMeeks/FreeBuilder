{"name":"@FreeBuilder","tagline":"Automatic generation of the Builder pattern for Java 1.6+","body":"> The Builder pattern is a good choice when designing classes whose constructors\r\n> or static factories would have more than a handful of parameters.\r\n> &mdash; <em>Effective Java, Second Edition</em>, page 39\r\n\r\n\r\n<h2 id=background>Background</h2>\r\n\r\nImplementing the [Builder pattern](http://en.wikipedia.org/wiki/Builder_pattern)\r\nin Java is tedious, error-prone and repetitive. Who hasn't seen a ten-argument\r\nconstructor, thought cross thoughts about the previous maintainers of the\r\nclass, then added \"just one more\"? Even a simple four-field class requires 39\r\nlines of code for the most basic builder API, or 72 lines if you don't use a\r\nutility like [AutoValue][] to generate the value boilerplate.\r\n\r\n`@FreeBuilder` produces all the boilerplate for you, as well as free extras like\r\nJavaDoc, getter methods, [collections support](#collections_and_maps),\r\n[nested builders](#nested_buildable_types), and [partial values](#partials)\r\n(used in testing), which are highly useful, but would very rarely justify\r\ntheir creation and maintenance burden in hand-crafted code. (We also reserve\r\nthe right to add more awesome methods in future!)\r\n\r\n\r\n> [The Builder pattern] is more verbose&#8230;so should only be used if there are\r\n> enough parameters, say, four or more. But keep in mind that you may want to add\r\n> parameters in the future. If you start out with constructors or static\r\n> factories, and add a builder when the class evolves to the point where the\r\n> number of parameters starts to get out of hand, the obsolete constructors or\r\n> static factories will stick out like a sore thumb. Therefore, it's often better\r\n> to start with a builder in the first place.\r\n> &mdash; <em>Effective Java, Second Edition</em>, page 39\r\n\r\n\r\n<h2 id=how_to_use_freebuilder>How to use <code>@FreeBuilder</code></h2>\r\n\r\n\r\n<h3 id=quick_start>Quick start</h3>\r\n\r\nAdd the `@FreeBuilder` artifact as an optional dependency to your Maven POM:\r\n\r\n```xml\r\n<dependencies>\r\n  <dependency>\r\n    <groupId>org.inferred</groupId>\r\n    <artifactId>freebuilder</artifactId>\r\n    <version>${version}</version>\r\n    <optional>true</optional>\r\n  </dependency>\r\n</dependencies>\r\n```\r\n\r\nCreate your value type (e.g. `Person`) as an interface or abstract class,\r\ncontaining an abstract accessor method for each desired field. This accessor\r\nmust be non-void, parameterless, and start with 'get' or 'is'. Add the\r\n`@FreeBuilder` annotation to your class, and it will automatically generate an\r\nimplementing class and a package-visible builder API (`Person_Builder`), which\r\nyou must subclass. For instance:\r\n\r\n\r\n```java\r\n@FreeBuilder\r\npublic interface Person {\r\n  /** Returns the person's full (English) name. */\r\n  String getName();\r\n  /** Returns the person's age in years, rounded down. */\r\n  int getAge();\r\n  /** Builder of {@link Person} instances. */\r\n  class Builder extends Person_Builder { }\r\n}\r\n```\r\n\r\nIf you are writing an abstract class, or using Java 8, you may wish to hide the\r\nbuilder's constructor and manually provide instead a static `builder()` method\r\non the value type (though <em>Effective Java</em> does not do this).\r\n\r\n\r\n<h3 id=what_you_get>What you get</h3>\r\n\r\nIf you write the Person interface shown above, you get:\r\n\r\n  * A builder class with:\r\n     * a no-args constructor\r\n     * JavaDoc\r\n     * getters (throwing `IllegalStateException` for unset fields)\r\n     * setters\r\n     * `mergeFrom` methods to copy data from existing values or builders\r\n     * a `build` method that verifies all fields have been set\r\n        * [see below for default values and constraint checking](#defaults_and_constraints)\r\n  * An implementation of `Person` with:\r\n     * `toString`\r\n     * `equals` and `hashCode`\r\n  * A [partial](#partials) implementation of `Person` for unit tests with:\r\n     * `UnsupportedOperationException`-throwing getters for unset fields\r\n     * `toString`\r\n     * `equals` and `hashCode`\r\n\r\n\r\n```java\r\nPerson person = new Person.Builder()\r\n    .setName(\"Phil\")\r\n    .setAge(31)\r\n    .build();\r\nSystem.out.println(person);  // Person{name=Phil, age=31}\r\n```\r\n\r\n\r\n<h3 id=defaults_and_constraints>Defaults and constraints</h3>\r\n\r\nWe use method overrides to add customization like default values and constraint\r\nchecks. For instance:\r\n\r\n\r\n```java\r\n@FreeBuilder\r\npublic interface Person {\r\n  /** Returns the person's full (English) name. */\r\n  String getName();\r\n  /** Returns the person's age in years, rounded down. */\r\n  int getAge();\r\n  /** Returns a human-readable description of the person. */\r\n  String getDescription();\r\n  /** Builder class for {@link Person}. */\r\n  class Builder extends Person_Builder {\r\n    public Builder() {\r\n      // Set defaults in the builder constructor.\r\n      setDescription(\"Indescribable\");\r\n    }\r\n    @Override public Builder setAge(int age) {\r\n      // Check single-field (argument) constraints in the setter methods.\r\n      checkArgument(age >= 18);\r\n      return super.setAge(age);\r\n    }\r\n    @Override public Person build() {\r\n      // Check cross-field (state) constraints in the build method.\r\n      Person person = super.build();\r\n      checkState(!person.getDescription().contains(person.getName()));\r\n      return person;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n<h3 id=optional_values>Optional values</h3>\r\n\r\nIf a property is optional&mdash;that is, has no reasonable default&mdash;then\r\nuse [the Optional type][]. It will default to Optional.absent(), and the Builder\r\nwill gain additional convenience setter methods.\r\n\r\n[the Optional type]: http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/base/Optional.html\r\n\r\n\r\n```java\r\n  /** Returns an optional human-readable description of the person. */\r\n  Optional<String> getDescription();\r\n```\r\n\r\nPrefer to use explicit defaults where meaningful, as it avoids the need for\r\nedge-case code; but prefer Optional to ad-hoc 'not set' defaults, like -1 or\r\nthe empty string, as it forces the user to think about those edge cases.\r\n@FreeBuilder does <strong>not</strong> support nulls and will throw a\r\nNullPointerException if one is passed to a setter.\r\n\r\n\r\n<h3 id=collections_and_maps>Collections and Maps</h3>\r\n\r\n`@FreeBuilder` has special support for <code>[List][]</code>,\r\n<code>[Set][]</code>, <code>[Multiset][]</code>, <code>[Map][]</code> and\r\n<code>[Multimap][]</code> properties:\r\n\r\n  * The Builder's <code>set<em>X</em></code> method is removed\r\n  * Mutation methods are added instead: <code>add<em>X</em></code> (collections),\r\n    <code>put<em>X</em></code> (maps) and <code>clear<em>X</em></code>\r\n  * The Builder's <code>get<em>X</em></code> method returns an unmodifiable view\r\n    of the current values: when the Builder is changed, the view also changes\r\n  * The property defaults to an empty collection\r\n  * The value type returns immutable collections\r\n\r\n[List]: http://docs.oracle.com/javase/tutorial/collections/interfaces/list.html\r\n[Set]: http://docs.oracle.com/javase/tutorial/collections/interfaces/set.html\r\n[Multiset]: https://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multiset\r\n[Map]: http://docs.oracle.com/javase/tutorial/collections/interfaces/map.html\r\n[Multimap]: https://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multimap\r\n\r\n\r\n<h3 id=nested_buildable_types>Nested buildable types</h3>\r\n\r\n`@FreeBuilder` has special support for buildable types like [protos][] and other\r\n`@FreeBuilder` types:\r\n\r\n  * The <code>set<em>X</em></code> method gains an overload for the property\r\n    type's Builder, as shorthand for <code>set<em>X</em>(x.build())</code>\r\n  * The <code>get<em>X</em></code> method is removed\r\n  * A <code>get<em>X</em>Builder</code> method is added instead, returning a\r\n    mutable Builder for the property\r\n  * The property inherits the defaults of its Builder type\r\n\r\n[protos]: https://developers.google.com/protocol-buffers/\r\n\r\n\r\n<h3 id=builder_construction>Builder construction</h3>\r\n\r\n<em>Effective Java</em> recommends passing required parameters in to the Builder\r\nconstructor. While we follow most of the recommendations therein, we explicitly\r\ndo not follow this one: while you gain compile-time verification that all\r\nparameters are set, you lose flexibility in client code, as well as opening\r\nyourself back up to the exact same subtle usage bugs as traditional constructors\r\nand factory methods. For the default `@FreeBuilder` case, where all parameters\r\nare required, this does not scale.\r\n\r\nIf you want to follow <em>Effective Java</em> more faithfully in your own types,\r\nhowever, just create the appropriate constructor in your builder subclass:\r\n\r\n\r\n```java\r\n    public Builder(String name, int age) {\r\n      // Set all initial values in the builder constructor\r\n      setName(name);\r\n      setAge(age);\r\n    }\r\n```\r\n\r\nImplementation note: in javac, we spot these fields being set in the\r\nconstructor, and do not check again at runtime. \r\n\r\n\r\n<h3 id=partials>Partials</h3>\r\n\r\nA <em>partial value</em> is an implementation of the value type which does not\r\nconform to the type's state constraints. It may be missing required fields, or\r\nit may violate a cross-field constraint.\r\n\r\n\r\n```java\r\nPerson person = new Person.Builder()\r\n    .setName(\"Phil\")\r\n    .buildPartial();  // build() would throw an IllegalStateException here\r\nSystem.out.println(person);  // prints: partial Person{name=\"Phil\"}\r\nperson.getAge();  // throws UnsupportedOperationException\r\n```\r\n\r\nAs partials violate the (legitimate) expectations of your program, they must\r\n<strong>not</strong> be created in production code. (They may also affect the\r\nperformance of your program, as the JVM cannot make as many optimizations.)\r\nHowever, when testing a component which does not rely on the full state\r\nrestrictions of the value type, partials can reduce the fragility of your test\r\nsuite, allowing you to add new required fields or other constraints to an\r\nexisting value type without breaking swathes of test code.\r\n\r\n\r\n<h3 id=ides>IDEs</h3>\r\n\r\nFollow your IDE's annotation processing instructions [[Eclipse instructions][];\r\n[IntelliJ instructions][]].\r\n\r\n[Eclipse instructions]: http://help.eclipse.org/indigo/index.jsp?topic=%2Forg.eclipse.jdt.doc.isv%2Fguide%2Fjdt_apt_getting_started.htm\r\n[IntelliJ instructions]: http://www.jetbrains.com/idea/webhelp/configuring-annotation-processing.html\r\n\r\n\r\n<h3 id=gwt>GWT</h3>\r\n\r\nTo enable [GWT][] serialization of the generated Value subclass, just add\r\n`@GwtCompatible(serializable = true)` to your `@FreeBuilder`-annotated type, and\r\nextend/implement `Serializable`. This will generate a [CustomFieldSerializer][],\r\nand ensure all necessary types are whitelisted.\r\n\r\n[GWT]: http://www.gwtproject.org/\r\n[CustomFieldSerializer]: http://www.gwtproject.org/javadoc/latest/com/google/gwt/user/client/rpc/CustomFieldSerializer.html\r\n\r\n\r\n<h2 id=alternatives>Alternatives</h2>\r\n\r\n\r\n<h3 id=autovalue_vs_freebuilder>AutoValue vs <code>@FreeBuilder</code></h3>\r\n\r\n<em><strong>Why is `@FreeBuilder` better than [AutoValue][]?</strong></em>\r\n\r\nIt's not! AutoValue provides an implementing class with a package-visible\r\nconstructor, so you can easily implement the Factory pattern. `@FreeBuilder`\r\nprovides an implementing class with a builder API, so you can easily implement\r\nand customize the Builder pattern. So, like chalk and cheese, which you use\r\ndepends on what you want!\r\n\r\nIf you're writing an immutable type that needs a small number of values to\r\ncreate (<em>Effective Java</em> suggests at most three), and is not likely to\r\nrequire more in future, use the Factory pattern. Otherwise, consider using\r\n`@FreeBuilder` to implement the Builder pattern.\r\n\r\n<em><strong>I used [AutoValue][], but now have more than three properties! How\r\ndo I migrate to `@FreeBuilder`?</strong></em>\r\n\r\n  1. Ensure your getter methods start with 'get' or 'is'.\r\n  2. Change your annotation to `@FreeBuilder`.\r\n  3. Rewrite your factory method(s) to use the builder API.\r\n  4. Inline your factory method(s) with a refactoring tool (e.g. Eclipse).\r\n\r\nYou can always skip step 4 and have both factory and builder methods, if that\r\nseems cleaner!\r\n\r\n\r\n<em><strong>Can I use both [AutoValue][] and `@FreeBuilder`?</strong></em>\r\n\r\nNot really. You can certainly use both annotations, but you will end up with\r\ntwo different implementing classes that never compare equal, even if they have\r\nthe same values.\r\n\r\n[AutoValue]: https://github.com/google/auto/tree/master/value\r\n\r\n\r\n<h3 id=proto_vs_freebuilder>Proto vs <code>@FreeBuilder</code></h3>\r\n\r\n<em><strong>[Protocol buffers][] have provided builders for ages. Why should I\r\nuse `@FreeBuilder`?</strong></em>\r\n\r\nProtocol buffers are cross-platform, backwards- and forwards-compatible, and\r\nhave a very efficient wire format. Unfortunately, they do not support custom\r\nvalidation logic; nor can you use appropriate Java domain types, such as\r\n[Instant][] or [Range][]. Generally, it will be clear which one is appropriate\r\nfor your use-case.\r\n\r\n[Protocol buffers]: https://developers.google.com/protocol-buffers/\r\n[Instant]: http://docs.oracle.com/javase/8/docs/api/java/time/Instant.html\r\n[Range]: http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Range.html\r\n\r\n\r\n<h2 id=why_free>Wait, why \"free\"?</h2>\r\n\r\n  * Free as in beer: you don't pay the cost of writing or maintaining the builder\r\n    code.\r\n  * Free as in flexible: you should always be able to customize the builder where\r\n    the defaults don't work for you.\r\n  * Free as in liberty: you can always drop `@FreeBuilder` and walk away with\r\n    the code it generated for you.\r\n\r\n<h2 id=license>License</h2>\r\n\r\n    Copyright 2014 Google Inc. All rights reserved.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n        http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}